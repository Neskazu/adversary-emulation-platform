filter {
  # Работает только с auth.log
  if [log][file][path] =~ "auth.log" {

    # 1. Сохраняем абсолютно сырой лог в event.original (стандарт ECS)
    mutate {
      copy => { "message" => "[event][original]" }
      add_tag => ["linux_auth"]
    }

    # 2. Парсим только заголовок Syslog
    # Мы выносим полезную нагрузку во временное поле msg_payload
    grok {
      match => {
        "message" => [
          "%{SYSLOGTIMESTAMP:syslog_timestamp}\s+%{HOSTNAME:host.name}\s+%{DATA:[process][name]}\[%{NUMBER:[process][pid]}\]:\s+%{GREEDYDATA:msg_payload}",
          "%{SYSLOGTIMESTAMP:syslog_timestamp}\s+%{HOSTNAME:host.name}\s+%{DATA:[process][name]}:\s+%{GREEDYDATA:msg_payload}"
        ]
      }
    }

    # 3. Если заголовок распарсился успешно
    if "_grokparsefailure" not in [tags] {
      
      # Нормализуем время
      date {
        match => ["syslog_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss"]
        target => "@timestamp"
      }

      # Теперь заменяем message на очищенный текст (без даты и хоста)
      mutate {
        copy => { "msg_payload" => "message" }
      }

      # --- SSH AUTH EVENTS ---
      if [process][name] == "sshd" {
        grok {
          match => {
            "message" => [
              "Failed %{WORD:[auth][method]} for (?:invalid user )?%{USER:[user][name]} from %{IP:[source][ip]} port %{INT:[source][port]}",
              "Accepted %{WORD:[auth][method]} for %{USER:[user][name]} from %{IP:[source][ip]} port %{INT:[source][port]}",
              "Invalid user %{USER:[user][name]} from %{IP:[source][ip]} port %{INT:[source][port]}",
              "authentication failure;.* rhost=%{IP:[source][ip]}"
            ]
          }
          tag_on_failure => ["_grokparsefailure_sshd"]
        }

        if [source][ip] {
          mutate {
            add_tag => ["ssh_auth_event"]
            remove_tag => ["_grokparsefailure_sshd", "_grok_sshd_no_ip_found"]
            }
        }

        if "Accepted" in [message] {
          mutate {
            add_field => {
              "[event][outcome]" => "success"
              "[event][type]" => "start"
            }
          }
        }

        if "Failed" in [message] or "Invalid" in [message] or "failure" in [message] {
          mutate {
            add_field => {
              "[event][outcome]" => "failure"
              "[event][type]" => "info"
            }
          }
        }
      }

      # --- SUDO EVENTS ---
      if [process][name] == "sudo" {
        grok {
          match => {
            "message" => [
              "%{USERNAME:user.name}\s+:\s+TTY=%{DATA:tty}\s+;\s+PWD=%{DATA:pwd}\s+;\s+USER=%{DATA:target_user}\s+;\s+COMMAND=%{GREEDYDATA:[process][command_line]}",
              "pam_unix\(sudo:session\):\s+session\s+%{WORD:event.action}\s+for\s+user\s+%{USERNAME:user.name}"
            ]
          }
          tag_on_failure => ["_grokparsefailure_sudo"]
        }

        mutate {
          add_tag => ["sudo_activity"]
          add_field => {
            "[event][category]" => "privilege"
            "[event][type]" => "change"
          }
        }
      }

      # Удаляем тег ошибки, так как заголовок-то мы распарсили успешно
      mutate {
        remove_tag => ["_grokparsefailure"]
      }
    }

    # Удаляем временное поле, чтобы не мусорить в Elastic
    mutate {
      remove_field => ["msg_payload", "syslog_timestamp"]
    }
  }
}